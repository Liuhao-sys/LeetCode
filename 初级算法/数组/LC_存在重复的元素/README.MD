这道简简单单的查重题真是一波三折

思路：

一开始想的是开一个数组，用数组的下标来充当nums中已经存在的数，但是测试的数据太大好像在在linux开不了

然后又用vector来装，艹，vector中查重太慢了，结果超时

然后又用unordered_set，这个容器，很快啊（对查重），这个可以

值得一提的是还有一种想法很开阔视野，就是先排序，那么两个相同的数必然在一块，这时候就可以比较前后两个是否相同来查重

​	

对了，有意思的来了

对与代码：

i<nums.size()-1;

和其变形

int len=nums.size();

i<len-1;

其实上面的代码绝对不同；nums.size() 返回的是unsigned ,当size为0减去1是会变成-1+|int|（一个大数，而不是-1）

因此，尽量用int len来替换size();

